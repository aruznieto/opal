/***************************************************************/
//
//Copyright (c) 2019 Esteban Egea-Lopez http://girtel.upct.es/~simulations
//
/**************************************************************/
#include "tests.h"
#include "../timer.h"
#include "../Opal.h"
#include <memory>
#include <fstream>
#include "../curvedMeshSimulation.h"
#include "../curvedFlatMeshSimulation.h"
#include "../basicSimulation.h"
#include "../flatSimulation.h"
#include "../singleDiffraction.h"
#include "../util.h"
#include "../rayDensityNormalizationSimulation.h"

using namespace opal;
using namespace optix;
using std::cout;
using std::endl;
using std::string;





BasicTests::BasicTests(OpalSceneManager*   sceneManager, float sphereRadius, bool useDepolarization) {
	this->sceneManager=sceneManager;
	this->sphereRadius=sphereRadius;
	this->useDepolarization=useDepolarization;
	this->config=nullptr;
}
BasicTests::~BasicTests() {
	if (config) {
		delete config;
	}
}
void BasicTests::setConfiguration(ConfigurationParser* config) {
	this->config=config;
}

//Horizontal plane test. To validate against a two-ray model. Only the direct ray and the ray reflected on the plane are expected to hit the sphere
void BasicTests::planeTest(int mode) {
	Timer timer;
	//float freq = 5.9e9f;
	//Frequency to be used by all transmissions
	float freq = 5.87e9f;
	//float freq = 868e6f;
	std::cout<<"Running plane test"<<std::endl;


	//Set the type of simulation to use
	if (useDepolarization) {
		//Use simulation with arbitrary LINEAR polarization (should be the default value for reflections if RDN is not used)

		LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
		//LPCurvedFlatMeshReflectionSimulation* sim = new LPCurvedFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	} else {
		//Use simulation with vertical or horizontal polarization (it is usually better to use arbitrary polarizations as above since the performance is almost equal)
		BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	}
	//Generating rays on launch is usually faster, specially for RDN
	sceneManager->enableGenerateRaysOnLaunch();	

	//Init context after setting simulation types and some configuration parameters and before doing anything else
	//Note that we are not using multichannel, so all the transmissions are assumed to use the frequency that we set here
	sceneManager->initContext(freq);

	//Print the hits on the sphere (after filtering)
	sceneManager->getSimulation()->setPrintHits(true);	

	//Print result on screen, in addition, it can be saved to CSV
	sceneManager->setPrintRecords(true);

	//Create here directly the mesh to be used as plane. For complex scenarios, it is usually loaded from a JSON file generated by Veneris as shown in next examples
	//Horizontal plane as quad at origin 
	//Have to pass vertices and the indexes of the triangles that make up the mesh
	int quadind[6] = { 0,1,2,1,0,3 };
	optix::float3 quadh[4] = { make_float3(-0.5f,0.0f,-0.5f),make_float3(0.5f,0.f,0.5f) ,make_float3(0.5f,0.f,-0.5f) ,make_float3(-0.5f,0.0f,0.5f) };

	//Scale to 200x200 m with a transformation matrix
	Matrix4x4 tm;
	tm.setRow(0, make_float4(200, 0, 0, 0.f));
	tm.setRow(1, make_float4(0, 1, 0, 0.f));
	tm.setRow(2, make_float4(0, 0, 200, 0.f));
	tm.setRow(3, make_float4(0, 0, 0,  1));

	//Set the EM material of the mesh
	MaterialEMProperties emProp1= sceneManager->ITUparametersToMaterial(3.75f,0.0f,0.038f,0.0f);
	//Set attenuation properties. Not used actually. There is a dependency on the frequency, we use -15 dB per 203 mm at 5 GHz => -75 dB/m
	emProp1.tattenuation = make_float2(0.1f,-75.f );

	//Add mesh to scenario
	sceneManager->addStaticMesh(4, quadh, 6, quadind, tm, emProp1 );

	//Alternatively set horizontal plane from a mesh file
	//std::vector<int> planeind = sceneManager->loadTrianglesFromFile("meshes/tri.txt");
	//std::vector<float3> planever = sceneManager->loadVerticesFromFile("meshes/vert.txt");
	////std::cout << "indices=" << planeind.size() << "vertices=" << planever.size() << std::endl;
	//Set the transformation matrix
	//Matrix4x4 tm;
	//tm.setRow(0, make_float4(10.0f, 0, 0, 0.0f));
	//tm.setRow(1, make_float4(0, 1, 0, 0.0f));
	//tm.setRow(2, make_float4(0, 0, 10.0f, 50.0f));
	//tm.setRow(3, make_float4(0, 0, 0, 1));
	//sceneManager->addStaticMesh(static_cast<int>(planever.size()), planever.data(), static_cast<int>(planeind.size()), planeind.data(), tm, emProp1);

	timer.start();

	//Different methods to create the sphere of rays to be launched
	if (mode==0) {
		//Equispaced sampling with 0.1 degrees of separation. The sphere is not uniformly samples
		sceneManager->createRaySphere2DSubstep(1, 1);
	} else if (mode==1) {
		//Uniform random sampling on the sphere from external buffer, the density is rayD/4pi rays/stereorad
		//It is not actually compatible with  enableGenerateRaysOnLaunch() above
		//Generating from external buffer allows to pass the exact ray pattern from an external source
		uint rayD=10000u;
		OpalRaySphereGenerator* gen=sceneManager->getRaySphereGenerator();
		gen->generateRandomUniformSphereOnDevice(rayD*rayD);
		sceneManager->createRaySphereFromExternalBuffer(rayD,rayD,gen->getDevicePointer());
	} else {
		//Generate rays over a given angular interval with a given separation
		//This is usually the preferred method for this kind of simulation
		//Note that the sampling is not uniform over the sphere
		//But if the density is high enough this is not usually a problem,
		sceneManager->createRaySphere2D(0.0f,0.1,180.0f,0.0f,0.1,360.0f);
	}


	//Set now the transmitters and receivers

	//Set transmitter position
	optix::float3 postx = make_float3(0.0f, 10.0f, 0.0f);
	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis

	//Add directly 100 receivers to have 100 reception points. Receivers can be arbitrarily close: even if the receivers sphere overlap, the hits 
	//are computed independently
	//Each receiver has an int as an external id 
	//The last parameter is a standard callback that will be called for each transmitter that receive hits
	//Any number of additional  callbacks can be added with the Opal API
	int nrx=100;
	for (int i=1;i<=nrx;++i) {
		//	sceneManager->addReceiver(i,make_float3(0.0,2.0f, 2),polarization, sphereRadius, sceneManager->printPower);
		sceneManager->addReceiver(i,make_float3(0.0,2.0f, i),polarization, sphereRadius, sceneManager->printPower);
	}

	timer.start();
	//Finish context. Usually called after all the static meshes have been added to the scene and  before launching. Receivers can actually be added later, also the ray launching sphere can also
	//be configured later
	sceneManager->finishSceneContext();

	//	sceneManager->setUsageReport();


	//std::cout << "Launching" << std::endl;
	//Note that any receiver can be a transmitter (transceiver), just by setting the transmitter position below equal to the 
	//desired receiver and the corresponding receiver id. In that case
	//receivers with an id equal to the transmitter will not receive anything (assuming the antenna cannot transmit and receive simultaneously)i

	//Also, one can transmit from any position, even if there is no actual transceiver at that position:
	//for transmissions is not necessary to register anything. In that case make sure the id of the transmitter is not equal to any of the receivers, 
	//in order for all receivers to get hits.  This is what we do here 
	ResultReport* report= sceneManager->transmit(0, 1.0f, postx, polarization);

	//Save results to CSV. This can be used in addition to the receiver callbacks.

	report->toCSV("plane.csv");

	//	
	timer.stop();
	std::cout<<"Time="<<timer.getTime()<<std::endl;


}


//Horizontal plane test with multichannel. To validate against a two-ray model.
//The difference with the previous test is that now every time we transmit we can use a different communication frequency
//Obviously if we use the same frequency as in the previous test we should get the same results
void BasicTests::planeTestMultichannel(int mode) {
	Timer timer;
	float freq = 5.9e9f;
	//Set this before calling init context
	sceneManager->enableMultiChannel();	
	if (useDepolarization) {

		LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
		//LPCurvedFlatMeshReflectionSimulation* sim = new LPCurvedFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	} else {
		BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	}
	//Generating rays on launch is usually faster, specially for RDN
	sceneManager->enableGenerateRaysOnLaunch();	

	//Even if we pass a frequency here, we can transmit with different ones. This one is the default one
	sceneManager->initContext(freq);
	sceneManager->getSimulation()->setPrintHits(true);	


	//Alternatively set horizontal plane from mesh file
	//std::vector<int> planeind = sceneManager->loadTrianglesFromFile("meshes/tri.txt");
	//std::vector<float3> planever = sceneManager->loadVerticesFromFile("meshes/vert.txt");
	////std::cout << "indices=" << planeind.size() << "vertices=" << planever.size() << std::endl;
	//Matrix4x4 tm;
	//tm.setRow(0, make_float4(10.0f, 0, 0, 0.0f));
	//tm.setRow(1, make_float4(0, 1, 0, 0.0f));
	//tm.setRow(2, make_float4(0, 0, 10.0f, 50.0f));
	//tm.setRow(3, make_float4(0, 0, 0, 1));
	//sceneManager->addStaticMesh(static_cast<int>(planever.size()), planever.data(), static_cast<int>(planeind.size()), planeind.data(), tm, emProp1);

	//Horizontal plane as quad at origin 
	int quadind[6] = { 0,1,2,1,0,3 };
	optix::float3 quadh[4] = { make_float3(-0.5f,0.0f,-0.5f),make_float3(0.5f,0.f,0.5f) ,make_float3(0.5f,0.f,-0.5f) ,make_float3(-0.5f,0.0f,0.5f) };

	//Scale to 200x200
	Matrix4x4 tm;
	tm.setRow(0, make_float4(200, 0, 0, 0.f));
	tm.setRow(1, make_float4(0, 1, 0, 0.f));
	tm.setRow(2, make_float4(0, 0, 200, 0.f));
	tm.setRow(3, make_float4(0, 0, 0,  1));


	MaterialEMProperties emProp1= sceneManager->ITUparametersToMaterial(3.75f,0.0f,0.038f,0.0f);
	emProp1.tattenuation = make_float2(0.1f,-75.f );

	//Add mesh to scenario
	sceneManager->addStaticMesh(4, quadh, 6, quadind, tm, emProp1 );


	timer.start();
	if (mode==0) {
		sceneManager->createRaySphere2DSubstep(1, 1);
	} else {
		uint rayD=10000u;
		OpalRaySphereGenerator* gen=sceneManager->getRaySphereGenerator();
		gen->generateRandomUniformSphereOnDevice(rayD*rayD);
		sceneManager->createRaySphereFromExternalBuffer(rayD,rayD,gen->getDevicePointer());
	}




	optix::float3 postx = make_float3(0.0f, 10.0f, 0.0f);
	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis


	//Add directly 100 receivers to have 100 reception points. Receivers can be arbitrarily close: even if the receivers sphere overlap, the hits 
	//are computed independently
	int nrx=100;
	for (int i=1;i<=nrx;++i) {
		//	sceneManager->addReceiver(i,make_float3(0.0,2.0f, 2),polarization, sphereRadius, sceneManager->printPower);
		sceneManager->addReceiver(i,make_float3(0.0,2.0f, i),polarization, sphereRadius, sceneManager->printPower);
	}

	timer.start();
	sceneManager->finishSceneContext();

	//	sceneManager->setUsageReport();


	//std::cout << "Launching" << std::endl;



	std::cout<<"Running plane test with f="<<freq<<std::endl;

	ResultReport total;

	//Notice how we pass now the transmission frequency as parameter to the transmit function
	ResultReport* report= sceneManager->transmit(0, 1.0f, postx, polarization, freq);

	//Merge reports for later
	total.merge(*report);
	//Change frequency
	freq=868e6;
	report= sceneManager->transmit(0, 1.0f, postx, polarization, freq);
	//Merge reports with the last transmission results
	total.merge(*report);
	//Save results to CSV
	total.toCSV("planeMulti.csv");

	//	}
	timer.stop();
	std::cout<<"Time="<<timer.getTime()<<std::endl;


	}




//Load scenario from files (similar to what is done in veneris-omnet). This function exemplifies  the general procedure for static scenarios, 
//where the scenario elements do not change and the receivers do not move. 
//The scenarios are created by: first, using the Veneris scenario builder (http://http://pcacribia.upct.es/veneris/scenario) to download the scenario,
//second, building the scenario with Veneris (http://pcacribia.upct.es/veneris/) and saving it as JSON file in the Opal menu. 
//In the next example we also show how to load the configuration from a file
void  BasicTests::loadScenario() {
	//Define a few receivers and transmitters
	optix::float3 rx0 = make_float3(1547.14f, 40.69f, 620.8f);
	optix::float3 rx1 = make_float3(1501.6, 25.1f, 609.9f);
	optix::float3 rx9 = make_float3(1632.9f, 21.67f, 560.55f);
	optix::float3 rx_e = make_float3(1462.1f, 45.33f, 622.9f);
	optix::float3 tx_m = make_float3(1040.74f, 32.89, 799.6f);
	optix::float3 tx_e = make_float3(1633.4f, 42.3, 679.9f);
	optix::float3 tx_f = make_float3(1520.5f, 26.836, 589.6f);
	optix::float3 rx3 = make_float3(875.22, 4.19f, 386.65f);
	optix::float3 tx3 = make_float3(862.62, 7.04f, 386.09f);
	Timer timer;
	float freq = 868e6f;
	std::cout<<"Load from scenario"<<std::endl;
	timer.start();	
	//Print results on screen, in addition, it can be saved to CSV
	sceneManager->setPrintRecords(true);
	sceneManager->enableGenerateRaysOnLaunch();
	//This parameter, which usually is 1e-3 or 1e-4, defines a minimum separation from the previous ray trace when it hits some element
	//It is used to remove self-intersections, when, due to numerical accuracy, the ray keeps hitting the same element every trace, without leaving it
	sceneManager->setMinEpsilon(1e-2);

	//We are going to use antenna radiation patterns
	sceneManager->setUseAntennaGain(true);

	//ComputeMode is now deprecated. It can be set but has no effect for backward compatibility.
	//Now, for every receiver in the scene, both induced voltage and electric field are computed.
	//Induced voltage on the antenna (complex, [V.real, V.im]), takes into account the effective length of the receiver, that is, the polarization and gain of the receiver antenna
	//Electric field provides the projection on the axis of the electric field at the receiver point. It is the EF that would be measured at that point in space, as if no antenna is there, so
	//receiver polarization and antenna gain are not take into account. It gives 3 complex numbers Ex, Ey and Ez
	ComputeMode mode=ComputeMode::VOLTAGE;

	if (useDepolarization) {
		LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
		//Deprecated
		sim->setComputeMode(mode);
		//Enable trace for this simulation if uncommented. It can only be used with one transmitter and one receiver 
		//A file called "ref-trace.txt" with the trajectory of all reflections is generated. The rays can later be visualized with Veneris
		//sim->setEnableTraceLog(true);


		//Allows to disable reflection simulation
		//sim->setEnableSimulation(false);
	} else {
		BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
		//Deprecated
		sim->setComputeMode(mode);
	}
	//Add diffraction
	SingleDiffraction* simd= new SingleDiffraction(sceneManager);
	sceneManager->setSimulation(simd);
	simd->setComputeMode(mode);
	//Enable trace for this simulation if uncommented. It can only be used with one transmitter and one receiver 
	//A file called "dif-trace.txt" with the trajectory of all reflections is generated. The rays can later be visualized with Veneris
	simd->setEnableTraceLog(true);

	//simd->setEnableSimulation(false);


	sceneManager->initContext(freq);

	//Exceptions. They should always be enabled for testing and disabled when the program is bug-free for performance
	sceneManager->enableExceptions();	

	//Load scenario files here. 
	ScenarioLoader* loader=new ScenarioLoader(sceneManager);
	std::string path("meshes/eldi.json");
	loader->loadJSONScenario(path);
	delete loader;
	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); 
	float3 posrx=rx3;

	sceneManager->addReceiver(0, posrx,polarization, sphereRadius, sceneManager->printPower);


	//Antenna patterns are loaded on the manager. They are usually reused by multiple transceivers, so we only load
	//the different patterns once and then use the gainId to assign them to receivers/transmitters
	AntennaGain gains=sceneManager->loadGainsFromFileIndBPower("dipole.txt");
	int gainId=sceneManager->registerAntennaGain(gains);

	//Assign the radiation pattern to our receiver
	sceneManager->registerReceiverGain(0,gainId);


	//The commented code exemplifies how to launch a single ray, usually for debug purposes
	//***Single ray transmit****
	//float3 mRay=normalize(make_float3(-0.004128737841, -0.9902680516, 0.1391119212));
	//sceneManager->createRaySphere2D(1,1,&mRay);

	//Create a standard launch ray sphere
	sceneManager->createRaySphere2D(0.0f,0.1,180.0f,0.0f,0.1,360.0f);

	sceneManager->finishSceneContext();

	optix::float3 postx = tx3;
	//Launch. In this case we are not saving the results to a CSV file. Since we have enabled it above, they will be printed on screen. Also the standard callback is called
	//for every receiver.
	sceneManager->transmit(1, 0.0251187f, postx, polarization);

	//Interchange. Some tests
	//	posrx=postx;
	//	sceneManager->updateReceiver(0,posrx);
	//	postx=rx1;
	//	sceneManager->transmit(1, 0.0251187f, postx, polarization);
	//
	timer.stop();
	std::cout<<"Time="<<timer.getTime()<<std::endl;
}

//Utility functions to load receivers from files, to be used in the next example
std::vector<float3> BasicTests::loadReceiversFromFile(std::string file) {
	// Load Receivers from File
	ScenarioLoader* sl=new ScenarioLoader(sceneManager);
	std::ifstream infile(file);
	if (!infile.good()) {
		std::cout<<"Error opening "<<file<<std::endl;
		throw  opal::Exception("loadReceiversFromFile(): error opening file");
	}
	std::cout<<"Loading receivers from  "<<file<<std::endl;
	std::string line;
	std::vector<float3> rx;
	while (std::getline(infile, line) ){
		optix::float3 v=sl->readFloat3(line);
		rx.push_back(v);
	}
	infile.close();
	delete sl;
	return rx;
}

std::vector<float3> BasicTests::loadReceiversFromJSON() {
	// Load Receivers from JSON configuration file (when we use configuration file)
	std::vector<nlohmann::json> nodes = config->getKey("nodes").get<std::vector<nlohmann::json>>();
	std::vector<float3> rx;
	std::cout<<"Loading receivers from JSON"<<std::endl;
	for (nlohmann::json n : nodes) {
		float x = config->getKey(n, "x").get<float>();
		float y = config->getKey(n, "y").get<float>();
		float z = config->getKey(n, "z").get<float>();
		optix::float3 nodePosition = make_float3(x, y, z);
		rx.push_back(nodePosition);
	}
	return rx;
}


//Again, a general scenario where we take the parameters from a JSON configuration file provide with the -f parameter
//The JSON file is flexible, does not have a predefined format, the user can use the desired keys as long as they are properly retrieved with the the json API
void  BasicTests::loadScenarioLoraFromConfigFile() {
	Timer timer;
	Timer timerRT;
	timer.start();
	sceneManager->setMinEpsilon(1e-3);
	sceneManager->setUseAntennaGain(true);
	sceneManager->enableGenerateRaysOnLaunch();

	//Get one of our keys from the config file
	std::string type=config->getKey("type").get<std::string>();
	//Another key
	float freq=config->getKey("freq").get<float>();

	//Overwrite parameters pass to the executable with the ones in the file
	int reflections=config->getKey("reflections").get<int>();
	sceneManager->setMaxReflections(reflections);

	sphereRadius=config->getKey("radius").get<float>();


	ComputeMode mode=ComputeMode::VOLTAGE;
	bool useRDN=false;
	if (type.compare("RDN")==0) {
		RayDensityNormalizationSimulation* sim = new RayDensityNormalizationSimulation(sceneManager);
		sceneManager->setSimulation(sim);
		useRDN=true;
	}  else {
		if (type.compare("flat")==0) {
			LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
			sceneManager->setSimulation(sim);
			sim->setComputeMode(mode);
		} else {
			BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
			sceneManager->setSimulation(sim);
			sim->setComputeMode(mode);
		}
	}
	//Add diffraction
	SingleDiffraction* simd= new SingleDiffraction(sceneManager);
	sceneManager->setSimulation(simd);
	simd->setComputeMode(mode);

	sceneManager->initContext(freq);
	//Exceptions
	//sceneManager->enableExceptions();

	//Load scenario file 
	std::string path=config->getKey("scenarioPath").get<std::string>();
	ScenarioLoader* loader=new ScenarioLoader(sceneManager);
	loader->loadJSONScenario(path);
	delete loader;
	//Gains
	int gainIdTx=-1;
	int gainIdRx=-1;
	std::string antenaGainTx = !config->getKey("gainPathTx").is_null() ? config->getKey("gainPathTx").get<std::string>() : "dipole.txt";
	AntennaGain gains = sceneManager->loadGainsFromFileIndBPower(antenaGainTx.c_str());
	gainIdTx=sceneManager->registerAntennaGain(gains);
	//Receiver gain. If it is equal there is no need to register it again, but it might be different
	std::string antenaGainRx = !config->getKey("gainPathRx").is_null() ? config->getKey("gainPathRx").get<std::string>() : "dipole.txt";
	AntennaGain gainsRx=sceneManager->loadGainsFromFileIndBPower(antenaGainRx.c_str());
	gainIdRx=sceneManager->registerAntennaGain(gainsRx);


	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f);
	float3 postx=make_float3(1527.6,39.47,634.26);

	std::vector<float3> rx{make_float3(0.0f, 0.0f, 0.0f)};
	if (!config->getKey("useNodesFile").is_null() && config->getKey("useNodesFile").get<bool>() == false) {
		if (!config->getKey("nodes").is_null()) {
			rx = loadReceiversFromJSON();
		}
	}
	else {
		std::string path = !config->getKey("nodesPath").is_null() ? config->getKey("nodesPath").get<std::string>() : "lora/dec22/rx-dec22.txt";
		rx = loadReceiversFromFile(path);
	}



	int i=0;
	for (auto p : rx) {
		sceneManager->addReceiver(i, p,polarization, sphereRadius, sceneManager->printPower);
		sceneManager->registerReceiverGain(i,gainIdRx);
		++i;
	}



	if (useRDN) {
		sceneManager->finishSceneContext();
		//For RDN we have to provide the initial ray density and set the type of RDN filtering 

		//This is the square root of the number of rays to be launched. It controls the density of rays for RDN
		//Since RDN is not generally bounded by GPU memory availability it can be very high
		int rayD=10000;
		//Set the angular range where the rays are going to be generated (in this case all the sphere) and the number of rays
		//per angula dimension: we are going to use a density of rayD*rayD/(4*pi) rays per stereorad at 1 m
		sceneManager->setRayRange(0.0,180.0,0.0,360.0,rayD,rayD);
		RayDensityNormalizationSimulation* s=dynamic_cast<RayDensityNormalizationSimulation*>(sceneManager->getSimulation(0));
		s->setInitialDensity(((float)sceneManager->getRaySphere().rayCount)/(4*M_PIf));
		//Internal RDN parameter. Keep this as default.
		s->setFiltering(2u);

	} else {
		sceneManager->finishSceneContext();
		sceneManager->createRaySphere2D(0.0f,0.1,180.0f,0.0f,0.1,360.0f);

		//If we want to increase the density we can use a lower angular separation as below. But depending on the number of 
		//receivers and the sphere radius we may get out of GPU memory
		//sceneManager->createRaySphere2D(0.0f,0.01,180.0f,0.0f,0.01,360.0f);
	}
	timerRT.start();
	//We use as tx id a non previously used id (i+1). This is the id used for transmit below.
	sceneManager->registerTransmitterGain(i+1,gainIdTx);

	sceneManager->transmit(i+1, 0.0251188, postx, polarization);
	timer.stop();
	timerRT.stop();
	std::cout<<"Time\t"<<timer.getTime()<<"\t"<<timerRT.getTime()<<std::endl;
}

//This example shows how to use dynamic elements in the simulation. These are elements that can be moved, rotated and scaled using a 
//transformation matrix and that interact with the rays traced. Notice that receivers (transceivers), if they do not have associated meshes can
//be just moved with the updateReceiver functions. Simularly, transmitter points are directly passed to the transmit function
void  BasicTests::addCompoundDynamicMeshes() {
	Timer timer;
	float freq = 5.9e9f;
	std::cout<<"Running addCompoundDynamicMeshes"<<std::endl;
	timer.start();	
	if (useDepolarization) {
		LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	} else {
		BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	}


	//Print result on screen, in addition, it can be saved to CSV
	sceneManager->setPrintRecords(true);

	sceneManager->initContext(freq);
	//Create a quad
	int quadind[6] = { 0,1,2,1,0,3 };
	optix::float3 quadv[4] = { make_float3(-0.5f,-0.5f,0.f),make_float3(0.5f,0.5f,0.f) ,make_float3(0.5f,-0.5f,0.f) ,make_float3(-0.5f,0.5f,0.f) };

	//45-degrees  x-titled down -0.7 quad with respect to parent

	optix::float3 quadt[4] = { make_float3(-0.5f, -1.1f, -0.9f),make_float3(0.5f, -0.3f, -0.1f) ,make_float3(0.5f, -0.3f, -0.1f) ,make_float3(0.5f, -0.3f, -0.1f) };

	//Create a transformation matrix for the group
	Matrix4x4 tm;
	tm.setRow(0, make_float4(1, 0, 0, 0.f));
	tm.setRow(1, make_float4(0, 1, 0, 2.f));
	tm.setRow(2, make_float4(0, 0, 1, 75.f));
	tm.setRow(3, make_float4(0, 0, 0.f, 1));

	//Materials can be passed as ITU parameters (a,b,c,d) or directly as relative permittivity and conductivity
	MaterialEMProperties emProp1;
	emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);
	emProp1.tattenuation = make_float2(0.1f,-75.f );

	//Creation of dynamic meshes  requires calling these 4 functions in this order
	sceneManager->addDynamicMeshGroup(0);
	sceneManager->addMeshToGroup(0, 4, quadv, 6, quadind, emProp1);  //Call for each new mesh in the group
	sceneManager->addMeshToGroup(0, 4, quadt, 6, quadind, emProp1);  //Call for each new mesh in the group
	sceneManager->updateTransformInGroup(0, tm);
	sceneManager->finishDynamicMeshGroup(0);


	sceneManager->createRaySphere2D(1, 1);
	//receivers
	optix::float3 posrx = make_float3(0.0f, 2.0f, 50.0f);


	optix::float3 postx = make_float3(0.0f, 2.0f, 0.0f);
	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis

	std::function<void(float,int)> cb=&sceneManager->printPower;
	sceneManager->addReceiver(1, posrx, polarization, 5.0f, cb);


	sceneManager->finishSceneContext();
	sceneManager->setPrintEnabled(1024 * 1024 * 1024);

	sceneManager->transmit(0, 1.0f, postx, polarization);


	//Translated and rotated 180 degrees, ends up symmetric to the previous position
	Matrix4x4 tm1;
	tm1.setRow(0, make_float4(-1.f, 0, 0, 0.f));
	tm1.setRow(1, make_float4(0, 1, 0, 2.f));
	tm1.setRow(2, make_float4(0, 0, -1.0f, -75.f));
	tm1.setRow(3, make_float4(0, 0, 0.f, 1));
	sceneManager->updateTransformInGroup(0, tm1);

	std::cout << "Only quad moved. Transmit again" << std::endl;
	sceneManager->transmit(0, 1.0f, postx, polarization);

	posrx = make_float3(0.0f, 2.0f, -50.0f);
	sceneManager->updateReceiver(1, posrx);

	std::cout << "Symmetric situation if everything has transformed well. Expect the  same power as first transmission. Transmit again" << std::endl;
	sceneManager->transmit(0, 1.0f, postx, polarization);

	timer.stop();
	std::cout<<"Time="<<timer.getTime()<<std::endl;



}

//A free space to test (no scenario elements) that the filtering procedure works. Even if you set a large 
//reception sphere and the tx and rx are close, you only get the direct ray. All the other rays must be filtered
//The power received should be the one that Friis formula predicts Pr=Pt*Gt*Gr*(lambda/4pi)^2

void BasicTests::freeSpace() {
	Timer timer;
	//float freq = 5.87e9f;
	float freq = 2e9f;
	std::cout<<"Running free space test"<<std::endl;

	//Init context before doing anything else
	if (useDepolarization) {
		LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	} else {
		BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	}


	//	sceneManager->enableGenerateRaysOnLaunch();
	sceneManager->setPrintEnabled(1024*1024*1024);
	sceneManager->initContext(freq);
	sceneManager->enableExceptions();	
	//Print detailed info about each hit
	sceneManager->getSimulation()->setPrintHits(true);
	//Print result on screen, in addition, it can be saved to CSV
	sceneManager->setPrintRecords(true);
	//	sceneManager->setMinEpsilon(0.0f);
	timer.start();
	optix::float3 postx = make_float3(500.0f, 900.0f, 0.0f);
	optix::float3 polarizationTx = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis
	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis
								    //optix::float3 posrx = make_float3(0.0f, 10.0f, 10.0f);

	optix::float3 posrx = make_float3(500.0f, 500.0f, 0.0f);
	sceneManager->addReceiver(0, posrx, polarization, sphereRadius, sceneManager->printPower);
	posrx = make_float3(500.0f, 500.0f+0.001, 0.0f);
	sceneManager->addReceiver(1, posrx, polarization, sphereRadius, sceneManager->printPower);
	posrx = make_float3(500.0f, 900.0f, 0.0f);
	sceneManager->addReceiver(2, posrx, polarization, sphereRadius, sceneManager->printPower);
	//	posrx = make_float3(500.0f, 500.0f, 0.0f);
	//	sceneManager->addReceiver(3, posrx, polarization, sphereRadius, sceneManager->printPower);

	//sceneManager->createRaySphere2DSubstep(1, 1); //0.1 degree delta step
	sceneManager->createRaySphere2D(0.0,0.1,180.0,0.0,0.1,360);	

	//***Single ray transmit****
	//	To transmit single have to comment out sceneManager->enableGenerateRaysOnLaunch();
	//float3 mRay=normalize(make_float3(500.0f,500.0f,0.0f)-make_float3(500.0f,900.0f,0.0f));
	//sceneManager->createRaySphere2D(1,1,&mRay);

	sceneManager->finishSceneContext();
	//sceneManager->transmit(0, 1.0f, postx, polarizationTx, false);
	sceneManager->transmit(2, 1.0f, postx, polarizationTx,false);
	timer.stop();
	std::cout<<"Time="<<timer.getTime()<<std::endl;

}
//Two quads as walls and two overlapping receivers
void BasicTests::quadTest( bool print, bool subSteps) {
	float freq=5.9e9;	
	LPCurvedFlatMeshReflectionSimulation* sim= new LPCurvedFlatMeshReflectionSimulation(sceneManager);
	sceneManager->setSimulation(sim);
	//Notice that in this example we do not generate the rays on GPU

	//Print result on screen, in addition, it can be saved to CSV.
	sceneManager->setPrintRecords(true);
	sceneManager->initContext(freq);
	//First quad
	int quadind[6] = { 0,1,2,1,0,3 };
	optix::float3 quadv[4] = { make_float3(-0.5f,-0.5f,0.f),make_float3(0.5f,0.5f,0.5f) ,make_float3(0.5f,-0.5f,0.0f) ,make_float3(-0.5f,0.5f,0.5f) };

	//One quad at (0,0,100)

	Matrix4x4 tm;
	tm.setRow(0, make_float4(1, 0, 0, 0.f));
	tm.setRow(1, make_float4(0, 1, 0, 0.f));
	tm.setRow(2, make_float4(0, 0, 1, 100.0f));
	tm.setRow(3, make_float4(0, 0, 0,  1));
	MaterialEMProperties emProp1;
	emProp1.tattenuation = make_float2(0.1f,-75.f );
	emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);

	sceneManager->addStaticMesh(4, quadv, 6, quadind, tm, emProp1 );

	//Second quad at (0,0,-10)
	int quadind2[6] = { 0,1,2,1,0,3 };
	optix::float3 quadv2[4] = { make_float3(-0.5f,-0.5f,0.f),make_float3(0.5f,0.5f,0.f) ,make_float3(0.5f,-0.5f,0.f) ,make_float3(-0.5f,0.5f,0.f) };


	Matrix4x4 tm2;
	tm2.setRow(0, make_float4(1, 0, 0, 0.f));
	tm2.setRow(1, make_float4(0, 1, 0, 0.f));
	tm2.setRow(2, make_float4(0, 0, 1, -10.0f));
	tm2.setRow(3, make_float4(0, 0, 0, 1));
	MaterialEMProperties emProp2;
	emProp2.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);


	sceneManager->addStaticMesh(4, quadv2, 6, quadind2, tm2, emProp2);

	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis


	optix::float3 posrx = make_float3(0.f, 0.f, 97.0f);
	//sceneManager->addReceiver(1, posrx,polarization, 1.0f, sceneManager->printPower);
	sceneManager->addReceiver(1, posrx,polarization, 5.0f, sceneManager->printPower);
	posrx=make_float3(0.0f,0.0f,99.0f);
	sceneManager->addReceiver(2, posrx, polarization, 5.0f, sceneManager->printPower);
	optix::float3 postx = make_float3(0.0f, 0.f,0.f);

	if (subSteps) {
		sceneManager->createRaySphere2DSubstep(1, 1);
	} else {
		sceneManager->createRaySphere2D(1, 1);
	}
	//sceneManager->createRaySphere2D(30, 30); //1 degree delta step

	sceneManager->finishSceneContext();

	if (print) {
		//Print detailed debug info about the ray tracing (rtPrintf functions in optix/ files).
		//WARNING: depending on the number of rays this info may be very large. Usually redirect output to file to examine
		sceneManager->setPrintEnabled(1024 * 1024 * 1024);
	}
	//sceneManager->setUsageReport();
	sceneManager->transmit(0, 1.0f,postx, polarization);
}
//Again the two-ray ground model, but updating the receiver position before each transmission (very inefficient, compare to just put all the receivers as in the previous examples).
void BasicTests::moveReceivers() {
	float freq = 5.9e9f;
	LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
	sceneManager->setSimulation(sim);


	sceneManager->initContext(freq);
	//Horizontal plane
	std::vector<int> planeind = sceneManager->loadTrianglesFromFile("meshes/tri.txt");
	std::vector<float3> planever = sceneManager->loadVerticesFromFile("meshes/vert.txt");
	//std::cout << "indices=" << planeind.size() << "vertices=" << planever.size() << std::endl;
	Matrix4x4 tm;
	tm.setRow(0, make_float4(10.0f, 0, 0, 0.0f));
	tm.setRow(1, make_float4(0, 1, 0, 0.0f));
	tm.setRow(2, make_float4(0, 0, 10.0f, 50.0f));
	tm.setRow(3, make_float4(0, 0, 0, 1));
	MaterialEMProperties emProp1;
	emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);
	emProp1.tattenuation = make_float2(0.1f,-75.f );
	sceneManager->addStaticMesh(static_cast<int>(planever.size()), planever.data(), static_cast<int>(planeind.size()), planeind.data(), tm, emProp1);


	//sceneManager->createRaySphere2D(1, 1);
	sceneManager->createRaySphere2DSubstep(1, 1);
	//receivers
	optix::float3 postx = make_float3(0.0f, 2.0f, 100.0f);


	optix::float3 posrx = make_float3(0.0f, 2.0f, 0.0f);
	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis

	sceneManager->addReceiver(1, posrx, polarization, 5.0f, sceneManager->printPower);


	sceneManager->finishSceneContext();
	sceneManager->setPrintEnabled(1024 * 1024 * 1024);

	for (size_t i = 0; i < 100; ++i)
	{
		posrx = make_float3(0.0f, 2.0f, 99.0f - i);
		sceneManager->updateReceiver(1, posrx);
		//We could change the position of transmitter as well
		//postx = make_float3(0.0f, 2.0f, 0.f);
		sceneManager->transmit(0, 1.0f, postx, polarization);
		//sceneManager->transmit(0, 1.0f, postx, polarization);

	}




}


//Same as above but now adding and removing dynamic meshes
void BasicTests::addRemoveDynamicMeshes( bool print, bool subSteps) {

	BasicFlatMeshReflectionSimulation* sim= new BasicFlatMeshReflectionSimulation(sceneManager);
	sceneManager->setSimulation(sim);
	//Quad
	int quadind[6] = { 0,1,2,1,0,3 };
	optix::float3 quadv[4] = { make_float3(-0.5f,-0.5f,0.f),make_float3(0.5f,0.5f,0.f) ,make_float3(0.5f,-0.5f,0.f) ,make_float3(-0.5f,0.5f,0.f) };



	Matrix4x4 tm;
	tm.setRow(0, make_float4(1, 0, 0, 0.f));
	tm.setRow(1, make_float4(0, 1, 0, 2.f));
	tm.setRow(2, make_float4(0, 0, 1, 75.f));
	tm.setRow(3, make_float4(0, 0, 0.f, 1));
	MaterialEMProperties emProp1;
	emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);
	emProp1.tattenuation = make_float2(0.1f,-75.f );

	//Creation of dynamic meshes  requires calling these 4 functions
	sceneManager->addDynamicMeshGroup(0);
	sceneManager->addMeshToGroup(0,4, quadv, 6, quadind,  emProp1);  //Call for each new mesh in the group
	sceneManager->updateTransformInGroup(0, tm); 
	sceneManager->finishDynamicMeshGroup(0);

	if (subSteps) {
		sceneManager->createRaySphere2DSubstep(1, 1);
	} else {
		sceneManager->createRaySphere2D(1, 1);
	}
	//receivers
	optix::float3 posrx = make_float3(0.0f, 2.0f, 50.0f);


	optix::float3 postx = make_float3(0.0f, 2.0f, 0.0f);

	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis

	sceneManager->addReceiver(0, posrx, polarization, 5.0f, sceneManager->printPower);


	sceneManager->finishSceneContext();
	if (print) {
		sceneManager->setPrintEnabled(1024 * 1024 * 1024);
	}

	sceneManager->transmit(1, 1.0f, postx, polarization);

	Matrix4x4 tm1;
	tm1.setRow(0, make_float4(1.f, 0, 0, 0.0f));
	tm1.setRow(1, make_float4(0, 1, 0, 2.f));
	tm1.setRow(2, make_float4(0, 0, 1.0f, -75.f));
	tm1.setRow(3, make_float4(0, 0, 0.f, 1));
	sceneManager->updateTransformInGroup(0, tm1);

	posrx = make_float3(0.0f, 2.0f, -50.0f);
	sceneManager->updateReceiver(0, posrx);

	std::cout << "Symmetric situation if everything has transformed well. Expect the same power as first transmission. Transmit again" << std::endl;
	sceneManager->transmit(1, 1.0f, postx, polarization);

	//Add a new quad 
	sceneManager->addDynamicMeshGroup(1);
	sceneManager->addMeshToGroup(1, 4, quadv, 6, quadind, emProp1);
	sceneManager->updateTransformInGroup(1, tm);
	sceneManager->finishDynamicMeshGroup(1);

	std::cout << "Transmit with new quad. Num quads= "<< sceneManager->getDynamicMeshes().size() << std::endl;
	sceneManager->transmit(1, 1.0f, postx, polarization);

	//Remove first quad
	sceneManager->removeDynamicMeshGroup(0);

	posrx = make_float3(0.0f, 2.0f, 50.0f);
	sceneManager->updateReceiver(0, posrx);
	std::cout << "Removing first quad. Expect again the first power. Transmit again.  Num quads= " << sceneManager->getDynamicMeshes().size() << std::endl;
	Matrix4x4 mym;
	Matrix4x4 mymi;
	sceneManager->getDynamicMeshes().at(1)->transform->getMatrix(0, mym.getData(), mymi.getData());
	std::cout << "Tm of quad 1: " <<  mym<< std::endl;
	sceneManager->transmit(1, 1.0f, postx, polarization);

	//Remove second quad
	sceneManager->removeDynamicMeshGroup(1);




}

//Penetration test. One cube, transmitter and receiver
void BasicTests::penetrationTest(bool print, bool subSteps) {

     Timer timer;

     std::cout << "Penetration test" << std::endl;
     //Cubes
     std::vector<int> cubeind = sceneManager->loadTrianglesFromFile("meshes/tricube.txt");
     std::vector<float3> cubevert = sceneManager->loadVerticesFromFile("meshes/vertcube.txt");
     //std::cout << "indices=" << cubeind.size() << "vertices=" << cubevert.size() << std::endl;
     //Cube(4) NW
     Matrix4x4 tm;
     tm.setRow(0, make_float4(40.0f, 0, 0, -30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 80.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     MaterialEMProperties emProp1;
     emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);
     	//There is a dependency on the frequency again, we use -15 dB per 203 mm at 5 GHz => -75 dB/m
     	emProp1.tattenuation = make_float2(0.1f,-75.f );
     //emProp1.dielectricConstant = make_float2(3.75f, -0.4576f);
     std::cout << "Adding NW. Em="<< emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);


     sceneManager->createRaySphere2D(30,60);	
     if (subSteps) {
	     sceneManager->createRaySphere2DSubstep(1, 1); //0.1 degree delta step
     } else {
	     sceneManager->createRaySphere2D(1, 1); //1 degree delta step
     }

     //receivers

     optix::float3 posrx = make_float3(-8.48f,10.0f, 78.0856f); //Hit with 60 degrees ray reflected on cube
     optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis
     sceneManager->addReceiver(1, posrx, polarization, 5.0f, sceneManager->printPower);


     sceneManager->enablePenetration();
     sceneManager->finishSceneContext();

     if (print) {
     	sceneManager->setPrintEnabled(1024 * 1024 * 1024);	
     }
     //sceneManager->setUsageReport();

     optix::float3 postx;
     timer.start();
     postx = make_float3(-50.0f, 10.0f, 50.0f);
     sceneManager->transmit(0, 1.0f, postx, polarization);

     timer.stop();
     std::cout<<"Time="<<timer.getTime()<<std::endl;

}
//Test penetration through plane
void BasicTests::penetrationPlane( bool print, bool subSteps) {

	Timer timer;

	std::cout << "Simulating penetration through plane" << std::endl;
	MaterialEMProperties emProp1;
	emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);
		//There is a dependency on the frequency again, we use -15 dB per 203 mm at 5 GHz => -75 dB/m
	emProp1.tattenuation = make_float2(0.1f,-15.f );
	//Horizontal plane as quad at origin 
	int quadind[6] = { 0,1,2,1,0,3 };
	optix::float3 quadh[4] = { make_float3(-0.5f,0.0f,-0.5f),make_float3(0.5f,0.f,0.5f) ,make_float3(0.5f,0.f,-0.5f) ,make_float3(-0.5f,0.0f,0.5f) };

	//Scale 100x100
	Matrix4x4 tm;
	tm.setRow(0, make_float4(100, 0, 0, 0.f));
	tm.setRow(1, make_float4(0, 1, 0, 0.f));
	tm.setRow(2, make_float4(0, 0, 100, 0.f));
	tm.setRow(3, make_float4(0, 0, 0,  1));


	std::cout << "Adding Plane. Em.dielectric=" << emProp1.dielectricConstant << std::endl;
	std::cout << "Adding Plane. Em.attenuation=" << emProp1.tattenuation << std::endl;
	sceneManager->addStaticMesh(4, quadh, 6, quadind, tm, emProp1 );

	if (subSteps) {
		sceneManager->createRaySphere2DSubstep(1, 1); //0.1 degree delta step
	} else {
		sceneManager->createRaySphere2D(1, 1); //1 degree delta step
	}

	//receivers

	optix::float3 posrx = make_float3(0.0f, 10.0f, 100.0f);
	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Parallel to the floor. Assuming as in Unity that forward is z-axis and up is y-axis
	sceneManager->addReceiver(1, posrx,polarization, 5.0f, sceneManager->printPower);


	//sceneManager->setMaxReflections(3u);

        sceneManager->enablePenetration();
	sceneManager->finishSceneContext();

	if (print) {
		sceneManager->setPrintEnabled(1024 * 1024 * 1024);	
	}
	//sceneManager->setUsageReport();

	optix::float3 postx;
	timer.start();

	timer.stop();
	std::cout<<"Time="<<timer.getTime()<<std::endl;
	postx = make_float3(-40.0f, 10.0f, 50.0f);
	sceneManager->transmit(0, 1.0f, postx, polarization);


}
//Street crossing test. Cubes are intended to be buildings and a plane is the floor.
//Here, we move the transmitter point, which is quite inefficient. It is better to directly add all the receivers in the 
//transmitter trajectory and put the transmitter in the receiver position, since the channel is symmetric.
//Setting a different number of reflections you will get received power from more positions
//Finally, if you also add diffraction you will see that you get received power from positions that previously did not get anything. This is done in diffraction.cpp
void BasicTests::crossingTest( bool print, bool subSteps, bool useDepolarization, float radius) {

     Timer timer;
     float freq = 5.9e9f;

     
     //Init context before doing anything else
     if (useDepolarization) {
     	LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
     	sceneManager->setSimulation(sim);
     } else {
     	BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
     	sceneManager->setSimulation(sim);
     }
     sceneManager->enableGenerateRaysOnLaunch();	
     sceneManager->setPrintRecords(true); 
     sceneManager->initContext(freq);

     std::cout << "Simulating crossing streets test" << std::endl;
     //Cubes
     std::vector<int> cubeind = sceneManager->loadTrianglesFromFile("meshes/tricube.txt");
     std::vector<float3> cubevert = sceneManager->loadVerticesFromFile("meshes/vertcube.txt");
     //std::cout << "indices=" << cubeind.size() << "vertices=" << cubevert.size() << std::endl;
     //Cube(4) NW
     Matrix4x4 tm;
     tm.setRow(0, make_float4(40.0f, 0, 0, -30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 80.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     MaterialEMProperties emProp1;
     emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);
     	//There is a dependency on the frequency again, we use -15 dB per 203 mm at 5 GHz => -75 dB/m
     	emProp1.tattenuation = make_float2(0.1f,-75.f );
     //emProp1.dielectricConstant = make_float2(3.75f, -0.4576f);
     std::cout << "Adding NW. Em="<< emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

     //Cube SW
     tm.setRow(0, make_float4(40.0f, 0, 0, -30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 20.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     std::cout << "Adding SW. Em = "<< emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);
     //Cube(2) NE

     tm.setRow(0, make_float4(40.0f, 0, 0, 30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 80.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     std::cout << "Adding NE. Em = "<< emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

     //Cube(1) SE

     tm.setRow(0, make_float4(40.0f, 0, 0, 30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 20.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     std::cout << "Adding SE. Em = "<< emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

     //Horizontal plane
     std::vector<int> planeind = sceneManager->loadTrianglesFromFile("meshes/tri.txt");
     std::vector<float3> planever = sceneManager->loadVerticesFromFile("meshes/vert.txt");
     //std::cout << "indices=" << planeind.size() << "vertices=" << planever.size() << std::endl;

     tm.setRow(0, make_float4(10.0f, 0, 0, 0.0f));
     tm.setRow(1, make_float4(0, 1, 0, 0.0f));
     tm.setRow(2, make_float4(0, 0, 10.0f, 50.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));

     //emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->defaultChannel.waveLength*0.15f);
     std::cout << "Adding Plane. Em=" << emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(planever.size()), planever.data(), static_cast<int>(planeind.size()), planeind.data(), tm, emProp1);

     if (subSteps) {
     	sceneManager->createRaySphere2DSubstep(1, 1); //0.1 degree delta step
     } else {
     	sceneManager->createRaySphere2D(1, 1); //1 degree delta step
     }

     //receivers

     optix::float3 posrx = make_float3(0.0f, 10.0f, 100.0f);
     optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis
     sceneManager->addReceiver(1, posrx,polarization, radius, sceneManager->printPower);


     //sceneManager->setMaxReflections(3u);

     sceneManager->finishSceneContext();

     if (print) {
     	sceneManager->setPrintEnabled(1024 * 1024 * 1024);	
     }
     //sceneManager->setUsageReport();

     optix::float3 postx;
     timer.start();

     for (int i = -50; i <= 50; ++i) {

     	float x=i;
     	postx = make_float3(x, 10.f, 50.0f);

     	sceneManager->transmit(0, 1.0f, postx, polarization);


     }
     timer.stop();
     std::cout<<"Time="<<timer.getTime()<<std::endl;


}
//Here we take advantage of the fact that, if everything is static, the channel is deterministic and symmetric, so
//we can just interchange the tx and receiver position and launch once
void BasicTests::crossingTestEfficient( bool print, bool subSteps, bool useDepolarization, float radius) {

     Timer timer;
     float freq = 5.9e9f;

     
     if (useDepolarization) {
     	LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
     	sceneManager->setSimulation(sim);
     } else {
     	BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
     	sceneManager->setSimulation(sim);
     }
     sceneManager->enableGenerateRaysOnLaunch();	
     sceneManager->setPrintRecords(true); 
     sceneManager->initContext(freq);

     std::cout << "Simulating crossing streets test" << std::endl;
     //Cubes
     std::vector<int> cubeind = sceneManager->loadTrianglesFromFile("meshes/tricube.txt");
     std::vector<float3> cubevert = sceneManager->loadVerticesFromFile("meshes/vertcube.txt");
     //std::cout << "indices=" << cubeind.size() << "vertices=" << cubevert.size() << std::endl;
     //Cube(4) NW
     Matrix4x4 tm;
     tm.setRow(0, make_float4(40.0f, 0, 0, -30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 80.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     MaterialEMProperties emProp1;
     emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);
     	//There is a dependency on the frequency again, we use -15 dB per 203 mm at 5 GHz => -75 dB/m
     	emProp1.tattenuation = make_float2(0.1f,-75.f );
     //emProp1.dielectricConstant = make_float2(3.75f, -0.4576f);
     std::cout << "Adding NW. Em="<< emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

     //Cube SW
     tm.setRow(0, make_float4(40.0f, 0, 0, -30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 20.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     std::cout << "Adding SW. Em = "<< emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);
     //Cube(2) NE

     tm.setRow(0, make_float4(40.0f, 0, 0, 30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 80.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     std::cout << "Adding NE. Em = "<< emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

     //Cube(1) SE

     tm.setRow(0, make_float4(40.0f, 0, 0, 30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 20.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     std::cout << "Adding SE. Em = "<< emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

     //Horizontal plane
     std::vector<int> planeind = sceneManager->loadTrianglesFromFile("meshes/tri.txt");
     std::vector<float3> planever = sceneManager->loadVerticesFromFile("meshes/vert.txt");
     //std::cout << "indices=" << planeind.size() << "vertices=" << planever.size() << std::endl;

     tm.setRow(0, make_float4(10.0f, 0, 0, 0.0f));
     tm.setRow(1, make_float4(0, 1, 0, 0.0f));
     tm.setRow(2, make_float4(0, 0, 10.0f, 50.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));

     //emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->defaultChannel.waveLength*0.15f);
     std::cout << "Adding Plane. Em=" << emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(planever.size()), planever.data(), static_cast<int>(planeind.size()), planeind.data(), tm, emProp1);

     if (subSteps) {
     	sceneManager->createRaySphere2DSubstep(1, 1); //0.1 degree delta step
     } else {
     	sceneManager->createRaySphere2D(1, 1); //1 degree delta step
     }

     //receivers
     optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis
     for (int i = -50; i <= 50; ++i) {

     	float x=i;
     	float3 posrx = make_float3(x, 10.f, 50.0f);
     	sceneManager->addReceiver(i, posrx,polarization, radius, sceneManager->printPower);



     }

     optix::float3 postx = make_float3(0.0f, 10.0f, 100.0f);


     //sceneManager->setMaxReflections(3u);

     sceneManager->finishSceneContext();

     if (print) {
     	sceneManager->setPrintEnabled(1024 * 1024 * 1024);	
     }
     //sceneManager->setUsageReport();

     timer.start();
     sceneManager->transmit(51, 1.0f, postx, polarization);


     
     timer.stop();
     std::cout<<"Time="<<timer.getTime()<<std::endl;


}


//Street crossing test. Cubes are intended to be buildings and a plane is the floor. A complex vehicle mesh is moved
void BasicTests::crossingTestAndVehicle(bool useDepolarization, float radius) {
     
     Timer timer;
     timer.start();
     float freq = 5.9e9f;
     if (useDepolarization) {
     	LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
     	sceneManager->setSimulation(sim);
     } else {
     	BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
     	sceneManager->setSimulation(sim);
     }
     sceneManager->enableGenerateRaysOnLaunch();	
     sceneManager->setPrintRecords(true); 
     sceneManager->initContext(freq);


     //Cubes
     std::vector<int> cubeind = sceneManager->loadTrianglesFromFile("meshes/tricube.txt");
     std::vector<float3> cubevert = sceneManager->loadVerticesFromFile("meshes/vertcube.txt");
     std::cout << "indices=" << cubeind.size() << "vertices=" << cubevert.size() << std::endl;
     //Cube(4) NW
     Matrix4x4 tm;
     tm.setRow(0, make_float4(40.0f, 0, 0, -30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 80.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     MaterialEMProperties emProp1;
     emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);
     	//There is a dependency on the frequency again, we use -15 dB per 203 mm at 5 GHz => -75 dB/m
     	emProp1.tattenuation = make_float2(0.1f,-75.f );
     //emProp1.dielectricConstant = make_float2(3.75f, -0.4576f);
     std::cout << "Adding NW. Em=" << emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

     //Cube SW
     tm.setRow(0, make_float4(40.0f, 0, 0, -30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 20.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     std::cout << "Adding SW. Em = " << emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);
     //Cube(2) NE

     tm.setRow(0, make_float4(40.0f, 0, 0, 30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 80.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     std::cout << "Adding NE. Em = " << emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

     //Cube(1) SE

     tm.setRow(0, make_float4(40.0f, 0, 0, 30.0f));
     tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
     tm.setRow(2, make_float4(0, 0, 40.0f, 20.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));
     std::cout << "Adding SE. Em = " << emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

     //Horizontal plane
     std::vector<int> planeind = sceneManager->loadTrianglesFromFile("meshes/tri.txt");
     std::vector<float3> planever = sceneManager->loadVerticesFromFile("meshes/vert.txt");
     //std::cout << "indices=" << planeind.size() << "vertices=" << planever.size() << std::endl;

     tm.setRow(0, make_float4(10.0f, 0, 0, 0.0f));
     tm.setRow(1, make_float4(0, 1, 0, 0.0f));
     tm.setRow(2, make_float4(0, 0, 10.0f, 50.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));

     //emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->defaultChannel.waveLength*0.15f);
     std::cout << "Adding Plane. Em=" << emProp1.dielectricConstant << std::endl;
     sceneManager->addStaticMesh(static_cast<int>(planever.size()), planever.data(), static_cast<int>(planeind.size()), planeind.data(), tm, emProp1);



     //Create vehicle group
     std::vector<int> bodyi = sceneManager->loadTrianglesFromFile("meshes/CC_ME_Body_R4-i.txt");
     std::vector<float3> bodyv = sceneManager->loadVerticesFromFile("meshes/CC_ME_Body_R4-v.txt");
     std::vector<int> wheeli = sceneManager->loadTrianglesFromFile("meshes/CC_ME_Wheel_FL-i.txt");
     std::vector<float3> wheelv = sceneManager->loadVerticesFromFile("meshes/CC_ME_Wheel_FL-v.txt");


     //Creation of dynamic meshes  requires calling these 4 functions
     sceneManager->addDynamicMeshGroup(0);
     sceneManager->addMeshToGroup(0, static_cast<int>(bodyv.size()), bodyv.data(), static_cast<int>(bodyi.size()),bodyi.data(), emProp1);  //Call for each new mesh in the group
     sceneManager->addMeshToGroup(0, static_cast<int>(wheelv.size()), wheelv.data(), static_cast<int>(wheeli.size()), wheeli.data(),emProp1);  //Call for each new mesh in the group
     wheeli = sceneManager->loadTrianglesFromFile("meshes/CC_ME_Wheel_FR-i.txt");
     wheelv = sceneManager->loadVerticesFromFile("meshes/CC_ME_Wheel_FR-v.txt");
     sceneManager->addMeshToGroup(0, static_cast<int>(wheelv.size()), wheelv.data(), static_cast<int>(wheeli.size()), wheeli.data(), emProp1);  //Call for each new mesh in the group

     wheeli = sceneManager->loadTrianglesFromFile("meshes/CC_ME_Wheel_BL-i.txt");
     wheelv = sceneManager->loadVerticesFromFile("meshes/CC_ME_Wheel_BL-v.txt");
     sceneManager->addMeshToGroup(0, static_cast<int>(wheelv.size()), wheelv.data(), static_cast<int>(wheeli.size()), wheeli.data(), emProp1);  //Call for each new mesh in the group
     wheeli = sceneManager->loadTrianglesFromFile("meshes/CC_ME_Wheel_BR-i.txt");
     wheelv = sceneManager->loadVerticesFromFile("meshes/CC_ME_Wheel_BR-v.txt");
     sceneManager->addMeshToGroup(0, static_cast<int>(wheelv.size()), wheelv.data(), static_cast<int>(wheeli.size()), wheeli.data(), emProp1);  //Call for each new mesh in the group


     tm.setRow(0, make_float4(0.0f, 0.f, 1.0f, -50.0f));
     tm.setRow(1, make_float4(0.f, 1.0f, 0.f, 0.6f));
     tm.setRow(2, make_float4(-1.f, 0.f, 0.0f, 50.0f));
     tm.setRow(3, make_float4(0, 0, 0, 1));

     sceneManager->updateTransformInGroup(0, tm);
     sceneManager->finishDynamicMeshGroup(0);



     //sceneManager->createRaySphere2D(1, 1);
     sceneManager->createRaySphere2DSubstep(1, 1);

     //receivers

     optix::float3 posrx = make_float3(0.0f, 2.0f, 100.0f);
     optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis
     sceneManager->addReceiver(1, posrx,polarization, radius, sceneManager->printPower);


     //sceneManager->setMaxReflections(3u);

     sceneManager->finishSceneContext();




     optix::float3 postx;

     for (int i = -50; i <= 50; ++i)
     {
     	postx = make_float3(i-2, 1.1f, 50.0f);//On top of the vehicle
     	tm.setRow(0, make_float4(-1.19209e-07f, 0.f, 1.0f, i));
     	tm.setRow(2, make_float4(-1.f, 0.f, -1.19209e-07f, 50.0f));
     	//std::cout << "tm=" << tm << std::endl;
     	sceneManager->updateTransformInGroup(0, tm);
     	sceneManager->transmit(0, 1.0f, postx, polarization);


     }
     timer.stop();
     std::cout<<"Time="<<timer.getTime()<<std::endl;


}

//The crossing test again but now using multiple transmitters at the same time.
//It can be used to test the performance of multiple simultaneous transmitters 
void BasicTests::crossingTestMulti( bool print, bool subSteps, bool useDepolarization, float radius) {

	Timer timer;
	float freq = 5.9e9f;

	
	//Init context before doing anything else
	if (useDepolarization) {
		LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	} else {
		BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
	}
	
	
     	sceneManager->enableGenerateRaysOnLaunch();	
        sceneManager->setPrintRecords(true); 
	sceneManager->initContext(freq);

	sceneManager->enableMultitransmitter();
	std::cout << "Simulating crossing streets test with multitransmitter" << std::endl;
	//Cubes
	std::vector<int> cubeind = sceneManager->loadTrianglesFromFile("meshes/tricube.txt");
	std::vector<float3> cubevert = sceneManager->loadVerticesFromFile("meshes/vertcube.txt");
	//std::cout << "indices=" << cubeind.size() << "vertices=" << cubevert.size() << std::endl;
	//Cube(4) NW
	Matrix4x4 tm;
	tm.setRow(0, make_float4(40.0f, 0, 0, -30.0f));
	tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
	tm.setRow(2, make_float4(0, 0, 40.0f, 80.0f));
	tm.setRow(3, make_float4(0, 0, 0, 1));
	MaterialEMProperties emProp1;
	emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->getChannelParameters().waveLength*0.038f);
		//There is a dependency on the frequency again, we use -15 dB per 203 mm at 5 GHz => -75 dB/m
		emProp1.tattenuation = make_float2(0.1f,-75.f );
	//emProp1.dielectricConstant = make_float2(3.75f, -0.4576f);
	std::cout << "Adding NW. Em="<< emProp1.dielectricConstant << std::endl;
	sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

	//Cube SW
	tm.setRow(0, make_float4(40.0f, 0, 0, -30.0f));
	tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
	tm.setRow(2, make_float4(0, 0, 40.0f, 20.0f));
	tm.setRow(3, make_float4(0, 0, 0, 1));
	std::cout << "Adding SW. Em = "<< emProp1.dielectricConstant << std::endl;
	sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);
	//Cube(2) NE

	tm.setRow(0, make_float4(40.0f, 0, 0, 30.0f));
	tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
	tm.setRow(2, make_float4(0, 0, 40.0f, 80.0f));
	tm.setRow(3, make_float4(0, 0, 0, 1));
	std::cout << "Adding NE. Em = "<< emProp1.dielectricConstant << std::endl;
	sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

	//Cube(1) SE

	tm.setRow(0, make_float4(40.0f, 0, 0, 30.0f));
	tm.setRow(1, make_float4(0, 40.0f, 0, 20.0f));
	tm.setRow(2, make_float4(0, 0, 40.0f, 20.0f));
	tm.setRow(3, make_float4(0, 0, 0, 1));
	std::cout << "Adding SE. Em = "<< emProp1.dielectricConstant << std::endl;
	sceneManager->addStaticMesh(static_cast<int>(cubevert.size()), cubevert.data(), static_cast<int>(cubeind.size()), cubeind.data(), tm, emProp1);

	//Horizontal plane
	std::vector<int> planeind = sceneManager->loadTrianglesFromFile("meshes/tri.txt");
	std::vector<float3> planever = sceneManager->loadVerticesFromFile("meshes/vert.txt");
	//std::cout << "indices=" << planeind.size() << "vertices=" << planever.size() << std::endl;

	tm.setRow(0, make_float4(10.0f, 0, 0, 0.0f));
	tm.setRow(1, make_float4(0, 1, 0, 0.0f));
	tm.setRow(2, make_float4(0, 0, 10.0f, 50.0f));
	tm.setRow(3, make_float4(0, 0, 0, 1));

	//emProp1.dielectricConstant = make_float2(3.75f, -60.0f*sceneManager->defaultChannel.waveLength*0.15f);
	std::cout << "Adding Plane. Em=" << emProp1.dielectricConstant << std::endl;
	sceneManager->addStaticMesh(static_cast<int>(planever.size()), planever.data(), static_cast<int>(planeind.size()), planeind.data(), tm, emProp1);

	if (subSteps) {
		sceneManager->createRaySphere2DSubstep(1, 1); //0.1 degree delta step
	} else {
		sceneManager->createRaySphere2D(1, 1); //1 degree delta step
	}

	
	

	//**** Test 2: One receiver, One transmitter per position

	timer.start();
	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis
	optix::float3 posrx = make_float3(0.0f, 10.0f, 100.0f);
	sceneManager->addReceiver(51, posrx, polarization, radius, sceneManager->printPower);
	sceneManager->finishSceneContext();

	if (print) {
		sceneManager->setPrintEnabled(1024 * 1024 * 1024);	
	}
	optix::float3 postx=make_float3(0.0f,0.0f,0.f);
	TransmitterManager* transmitterManager=sceneManager->getTransmitterManager();


		
	for (int i = -50; i <= 50; ++i) {

		float x=i;
		postx = make_float3(x, 10.f, 50.0f);
		transmitterManager->registerTransmitter(i,postx,polarization,1.0f);
		transmitterManager->addTransmitterToGroup(i,1.0f,postx,polarization);
		//sceneManager->transmit(0, 1.0f, postx, polarization);


	}
	sceneManager->groupTransmit();
	
	
	timer.stop();
	std::cout<<"Time="<<timer.getTime()<<std::endl;
	//		postx = make_float3(-18.0f, 10.0f, 50.0f);
	//		sceneManager->transmit(0, 1.0f, postx, polarization);


}
//Custom Calback that we use to print extended info
//ResultRecord is defined in results.h
void BasicTests::exampleCallback(ResultRecord r, int txId) {
	std::cout <<"Custom callback called. Received transmission from "<< txId<< "with the following record "<<r.toString()<<std::endl;
}
//Custom Calback that we use to print extended info
void BasicTests::anotherCallback(ResultRecord r, int txId) {
	std::cout <<"Another custom callback called. Received transmission from "<< txId<< "with the following record "<<r.toString()<<std::endl;
}

//Calback to get information for each hit on a receiver per simulation type
void BasicTests::hitCallback(int txId, int rxId, HitRecord r){
	std::cout <<"Custom per hit callback. New hit from "<<txId<<" on receiver "<<rxId << " with info "<<r.toString()<<std::endl;
}

//How to use callbacks to retrieve information from Opal.
//We can set any number of general callbacks per receivers
//We can also set callbacks to get information from individual hits on a receiver
void BasicTests::useCallbacks(int mode) {
	Timer timer;
	//float freq = 5.9e9f;
	//Frequency to be used by all transmissions
	float freq = 5.87e9f;
	//float freq = 868e6f;
	std::cout<<"Running plane test"<<std::endl;


	//Set the type of simulation to use
	if (useDepolarization) {
		//Use simulation with arbitrary LINEAR polarization (should be the default value for reflections if RDN is not used)

		LPFlatMeshReflectionSimulation* sim = new LPFlatMeshReflectionSimulation(sceneManager);
		//This callback is per hit processed by the simulation
    		sim->setCallback(std::bind(&BasicTests::hitCallback, this, std::placeholders::_1,std::placeholders::_2, std::placeholders::_3));
		sceneManager->setSimulation(sim);
	} else {
		//Use simulation with vertical or horizontal polarization (it is usually better to use arbitrary polarizations as above since the performance is almost equal)
		BasicFlatMeshReflectionSimulation* sim = new BasicFlatMeshReflectionSimulation(sceneManager);
		sceneManager->setSimulation(sim);
    		sim->setCallback(std::bind(&BasicTests::hitCallback, this, std::placeholders::_1,std::placeholders::_2, std::placeholders::_3));
	}
	//Generating rays on launch is usually faster, specially for RDN
	sceneManager->enableGenerateRaysOnLaunch();	

	//Have to set this to invoke callbacks: they are not called by default
	sceneManager->setExecuteCallback(true);
	
	
	//Init context after setting simulation types and some configuration parameters and before doing anything else
	//Note that we are not using multichannel, so all the transmissions are assumed to use the frequency that we set here
	sceneManager->initContext(freq);


	//Print result on screen, in addition, it can be saved to CSV
	//sceneManager->setPrintRecords(true);

	//Create here directly the mesh to be used as plane. For complex scenarios, it is usually loaded from a JSON file generated by Veneris as shown in next examples
	//Horizontal plane as quad at origin 
	//Have to pass vertices and the indexes of the triangles that make up the mesh
	int quadind[6] = { 0,1,2,1,0,3 };
	optix::float3 quadh[4] = { make_float3(-0.5f,0.0f,-0.5f),make_float3(0.5f,0.f,0.5f) ,make_float3(0.5f,0.f,-0.5f) ,make_float3(-0.5f,0.0f,0.5f) };

	//Scale to 200x200 m with a transformation matrix
	Matrix4x4 tm;
	tm.setRow(0, make_float4(200, 0, 0, 0.f));
	tm.setRow(1, make_float4(0, 1, 0, 0.f));
	tm.setRow(2, make_float4(0, 0, 200, 0.f));
	tm.setRow(3, make_float4(0, 0, 0,  1));

	//Set the EM material of the mesh
	MaterialEMProperties emProp1= sceneManager->ITUparametersToMaterial(3.75f,0.0f,0.038f,0.0f);
	//Set attenuation properties. Not used actually. There is a dependency on the frequency, we use -15 dB per 203 mm at 5 GHz => -75 dB/m
	emProp1.tattenuation = make_float2(0.1f,-75.f );

	//Add mesh to scenario
	sceneManager->addStaticMesh(4, quadh, 6, quadind, tm, emProp1 );

	//Alternatively set horizontal plane from a mesh file
	//std::vector<int> planeind = sceneManager->loadTrianglesFromFile("meshes/tri.txt");
	//std::vector<float3> planever = sceneManager->loadVerticesFromFile("meshes/vert.txt");
	////std::cout << "indices=" << planeind.size() << "vertices=" << planever.size() << std::endl;
	//Set the transformation matrix
	//Matrix4x4 tm;
	//tm.setRow(0, make_float4(10.0f, 0, 0, 0.0f));
	//tm.setRow(1, make_float4(0, 1, 0, 0.0f));
	//tm.setRow(2, make_float4(0, 0, 10.0f, 50.0f));
	//tm.setRow(3, make_float4(0, 0, 0, 1));
	//sceneManager->addStaticMesh(static_cast<int>(planever.size()), planever.data(), static_cast<int>(planeind.size()), planeind.data(), tm, emProp1);

	timer.start();

	//Different methods to create the sphere of rays to be launched
	if (mode==0) {
		//Equispaced sampling with 0.1 degrees of separation. The sphere is not uniformly samples
		sceneManager->createRaySphere2DSubstep(1, 1);
	} else if (mode==1) {
		//Uniform random sampling on the sphere from external buffer, the density is rayD/4pi rays/stereorad
		//It is not actually compatible with  enableGenerateRaysOnLaunch() above
		//Generating from external buffer allows to pass the exact ray pattern from an external source
		uint rayD=10000u;
		OpalRaySphereGenerator* gen=sceneManager->getRaySphereGenerator();
		gen->generateRandomUniformSphereOnDevice(rayD*rayD);
		sceneManager->createRaySphereFromExternalBuffer(rayD,rayD,gen->getDevicePointer());
	} else {
		//Generate rays over a given angular interval with a given separation
		//This is usually the preferred method for this kind of simulation
		//Note that the sampling is not uniform over the sphere
		//But if the density is high enough this is not usually a problem,
		sceneManager->createRaySphere2D(0.0f,0.1,180.0f,0.0f,0.1,360.0f);
	}


	//Set now the transmitters and receivers

	//Set transmitter position
	optix::float3 postx = make_float3(0.0f, 10.0f, 0.0f);
	optix::float3 polarization = make_float3(0.0f, 1.0f, 0.0f); //Perpendicular to the floor. Assuming as in Unity that forward is z-axis and up is y-axis

	//The last parameter is a standard callback that reports received power from a given transmitter, that will be called for each transmitter that receive hits
	//Any number of additional  callbacks can be added with the Opal API as shown below
	//We put only two receivers here to make easier the visualization of the callbacks invokation
	int nrx=2;
	for (int i=1;i<=nrx;++i) {
		//	sceneManager->addReceiver(i,make_float3(0.0,2.0f, 2),polarization, sphereRadius, sceneManager->printPower);
		sceneManager->addReceiver(i,make_float3(0.0,2.0f, i),polarization, sphereRadius, sceneManager->printPower);
		//We set our callbacks here. We can set any number of general callbacks per receiver
    		sceneManager->setReceiverHitCallback(i,std::bind(&BasicTests::exampleCallback, this, std::placeholders::_1,std::placeholders::_2));
    		sceneManager->setReceiverHitCallback(i,std::bind(&BasicTests::anotherCallback, this, std::placeholders::_1,std::placeholders::_2));
	}

	timer.start();
	//Finish context. Usually called after all the static meshes have been added to the scene and  before launching. Receivers can actually be added later, also the ray launching sphere can also
	//be configured later
	sceneManager->finishSceneContext();



	//	sceneManager->setUsageReport();


	//std::cout << "Launching" << std::endl;
	//Note that any receiver can be a transmitter (transceiver), just by setting the transmitter position below equal to the 
	//desired receiver and the corresponding receiver id. In that case
	//receivers with an id equal to the transmitter will not receive anything (assuming the antenna cannot transmit and receive simultaneously)i

	//Also, one can transmit from any position, even if there is no actual transceiver at that position:
	//for transmissions is not necessary to register anything. In that case make sure the id of the transmitter is not equal to any of the receivers, 
	//in order for all receivers to get hits.  This is what we do here 
	ResultReport* report= sceneManager->transmit(0, 1.0f, postx, polarization);

	//Save results to CSV. This can be used in addition to the receiver callbacks.

	report->toCSV("plane.csv");

	//	
	timer.stop();
	std::cout<<"Time="<<timer.getTime()<<std::endl;


}

std::vector<int> BasicTests::parseTestString(std::string test) {
	//Parse tests
	std::vector<int> tokens; 
	if (test.empty()) {
		throw opal::Exception("tunnelsBase::parseTestString(): empty test string");
	}	

	// stringstream class check1 
	std::stringstream check1(test); 

	std::string intermediate; 

	while(getline(check1, intermediate, '-')) 
	{ 
		tokens.push_back(std::stoi(intermediate)); 
	} 
	return tokens;
}





